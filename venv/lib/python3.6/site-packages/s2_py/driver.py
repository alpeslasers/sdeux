# -*- coding: utf-8 -*-
"""
Created by chiesa on 27.08.15

Copyright 2015 Alpes Lasers SA, Neuchatel, Switzerland

Adapted from external_cavity_server.server.pulser_driver by juraj
"""
import logging
import time
from time import sleep
from s2_py.utils.synchronized import synchronized

__author__ = 'chiesa'
__copyright__ = "Copyright 2015, Alpes Lasers SA" 

from functools import wraps
import threading

from s2_py import serial_open, S2_PULSING_FULL_EXTERNAL, S2_PULSING_INTERNAL, \
    s2_set_settings, S2_settings, S2_info, s2_query_info, s2_query_settings, S2_PULSING_OFF, serial_close, \
    s2_serial_setup, S2_STATUS_OK, S2_STATUS_UNDERVOLTAGE, S2_STATUS_OVERCURRENT, \
    s2_check_API_compatible, s2_reset_status_flag, S2_BAUD, NULL, S2_PULSING_MODE_A, S2_PULSING_MODE_B


class PulserError(Exception):
    """
    Error raised when some problem with the pulser occurs.
    """
    pass


class PulserCompatibilityError(Exception):
    """
    Error raised when a compatibility problem is detected.
    """
    pass


def _filter_mapping(mydict, target):
    c = [k for k in mydict if mydict[k] == target]
    if len(c) == 1:
        return c[0]
    else:
        return 'undefined'


class BaseStructureWrapper(object):

    def __init__(self, structure):
        """
        :param structure ctypes.Structure:
        :return:
        """
        self.structure = structure

    def _set_value(self, fieldname, value):
        setattr(self.structure, fieldname, value)


class S2SettingsWrapper(BaseStructureWrapper):

    PULS_MODES = {"off": S2_PULSING_OFF,
                  "external": S2_PULSING_FULL_EXTERNAL,
                  "internal": S2_PULSING_INTERNAL,
                  "modeA": S2_PULSING_MODE_A,
                  "modeB": S2_PULSING_MODE_B
                  }

    def __init__(self, structure, s2info, check_bounds=False):
        super(S2SettingsWrapper, self).__init__(structure)
        self.s2info = s2info
        self.checkBounds = check_bounds

    def init_settings(self):
        self.set_pulsing_mode('off')
        self.set_pulse_period(self.s2info.period_min)
        self.set_pulse_width(self.s2info.pulse_width_min)
        self.set_output_voltage(self.s2info.voltage_min)
        self.structure.output_current_limit = self.s2info.curr_limit_max

    def set_pulsing_mode(self, mode):
        if mode not in self.PULS_MODES:
            raise ValueError('Unknown pulse mode {0}'.format(mode))
        self._set_value('pulsing_mode', self.PULS_MODES[mode])

    def get_pulsing_mode(self):
        return _filter_mapping(self.PULS_MODES, self.structure.pulsing_mode)

    def set_pulse_period(self, value):
        """
        Sets the pulse period
        :param value: pulse period in nanoseconds
        :return:
        """
        if self.checkBounds:
            if not self.s2info.period_min <= value <= self.s2info.period_max:
                raise PulserError("Trying to set pulse period {0}, which is not in the allowed range".format(value))
        self._set_value('pulse_period', int(value / self.s2info.step_ns))

    def get_pulse_period(self):
        """
        Get the pulse period
        :return: the pulse period in nanoseconds
        """
        return self.structure.pulse_period * self.s2info.step_ns

    def set_pulse_width(self, value):
        """
        Sets the pulse width
        :param value: the pulse width in nanoseconds
        :return:
        """
        if self.checkBounds:
            if not self.s2info.pulse_width_min <= value <= self.s2info.pulse_width_max:
                raise PulserError("Trying to set pulse width {0}, which is not in the allowed range".format(value))
        self._set_value('pulse_width', int(value / self.s2info.step_ns))

    def get_pulse_width(self):
        """
        Get the pulse width
        :return: the pulse width in nanoseconds
        """
        return self.structure.pulse_width * self.s2info.step_ns

    def set_output_voltage(self, value):
        """
        Sets the voltage
        :param value: voltage in Volts
        :return:
        """
        if self.checkBounds:
            if not self.s2info.voltage_min <= value <= self.s2info.voltage_max:
                raise PulserError("Trying to set voltage {0}, which is not in the allowed range".format(value))
        self._set_value('output_voltage_set', value)

    def get_output_voltage(self):
        """
        Gets the output voltage settings
        :return: the voltage in Volts
        """
        return self.structure.output_voltage_set

    def set_output_current_limit(self, value):
        if self.checkBounds:
            if not self.s2info.curr_limit_min <= value <= self.s2info.curr_limit_max:
                raise PulserError('Trying to set current limit {0}, which is not in the allowed range.'.format(value))
        self._set_value('output_current_limit', value)

    def to_dict(self):
        return dict(pulse_period=self.get_pulse_period(),
                    pulse_width=self.get_pulse_width(),
                    applied_voltage=self.get_output_voltage(),
                    pulsing_mode=self.get_pulsing_mode(),
                    current_limit=self.structure.output_current_limit)

    def _get_setters(self):
        return dict(pulse_period=self.set_pulse_period,
                    pulse_width=self.set_pulse_width,
                    applied_voltage=self.set_output_voltage,
                    pulsing_mode=self.set_pulsing_mode,
                    current_limit=self.set_output_current_limit)

    def update(self, my_dict):
        setters = self._get_setters()
        for k, v in list(my_dict.items()):
            setters[k](v)


class S2InfoWrapper(BaseStructureWrapper):

    STATES = {"ok": S2_STATUS_OK,
              "undervoltage": S2_STATUS_UNDERVOLTAGE,
              "overcurrent": S2_STATUS_OVERCURRENT}

    def __init__(self, structure):
        super(S2InfoWrapper, self).__init__(structure)
        self.step_ns = 20.0
        self.voltage_min = 0
        self.voltage_max = 25
        self.voltage_res = 0.005
        self.period_min = 500.0
        self.period_max = 2 ** 16 * self.step_ns
        self.pulse_width_min = 0
        self.pulse_width_max = 2 ** 16 * self.step_ns
        self.curr_limit_min = 0.0
        self.curr_limit_max = 30.0
        self.min_pulse_width_meas = 200.0
        self.signal_stabilization_sec = 0.5
        self.measurement_stabilization_sec = 0.1

    def get_status(self):
        return _filter_mapping(self.STATES, self.structure.status)

    def to_dict(self):
        return dict(device_id=self.structure.device_id,
                    sw_version=self.structure.sw_version,
                    hw_version=self.structure.hw_version,
                    measured_voltage=self.structure.output_voltage_measured,
                    measured_current=self.structure.output_current_measured,
                    status=self.get_status(),
                    min_pulse_width_meas=self.min_pulse_width_meas,
                    step_ns=self.step_ns,
                    voltage_min=self.voltage_min,
                    voltage_max=self.voltage_max,
                    voltage_res=self.voltage_res,
                    period_min=self.period_min,
                    period_max=self.period_max,
                    pulse_width_min=self.pulse_width_min,
                    pulse_width_max=self.pulse_width_max,
                    curr_limit_max=self.curr_limit_max,
                    signal_stabilization_sec=self.signal_stabilization_sec,
                    measurement_stabilization_sec=self.measurement_stabilization_sec)


def device_open_required(f):
    @wraps(f)
    def new_f(self, *args, **kwargs):
        if not isinstance(self, PulserDriver):
            print(type(self))
            raise ValueError("This decorator can be used only on PulserDriver type!")
        if not self._open:
            raise IOError("Device must be open before it is used!")
        return f(self, *args, **kwargs)
    return new_f


class PulserDriver(object):

    ERRORS = {-3: 'INVALID_PACKET_TYPE',
              -2: 'INVALID_CHECKSUM',
              0: 'SERIAL_ERR_OK',
              1: 'SERIAL_ERR_SYSTEM',
              2: 'SERIAL_ERR_UNKNOWN',
              3: 'SERIAL_ERR_INVALID_BAUD',
              4: 'SERIAL_ERR_INVALID_BITS',
              5: 'SERIAL_ERR_INVALID_PARITY',
              6: 'SERIAL_ERR_INVALID_STOPBIT',
              7: 'SERIAL_ERR_NODATA'}

    @classmethod
    def _get_error_name(cls, error_code):
        return cls.ERRORS.get(error_code, 'UNDEFINED ERROR {}'.format(error_code))

    def __init__(self, port_name, verbose=True):
        self._verbose = verbose
        self._port_name = port_name
        self._port = None
        self._open = False
        self._myLock = threading.RLock()
        self._settings_wrapper = S2SettingsWrapper
        self._info_wrapper = S2InfoWrapper
        self.s2i = None
        self._lastSetTime = time.time()
        self._logger = logging.getLogger(self.__class__.__name__)

    @synchronized
    def open(self):
        self._port = serial_open(self._port_name.encode('utf-8'))
        if self._port==NULL:
            raise IOError("Device not found at " + self._port_name)
        ret = s2_serial_setup(self._port, S2_BAUD)
        if ret != 0:
            raise PulserError("Failed to set up the serial port. Error: " + PulserDriver._get_error_name(ret))

        # API - firmware compatibility test
        compatibility_test = s2_check_API_compatible(self._port)
        if compatibility_test != 0:
            serial_close(self._port)
        if compatibility_test > 0:
            raise PulserError("API version older than board firmware")
        if compatibility_test < 0:
            raise PulserError("API version newer than board firmware")

        self._open = True
        self.s2i = self.get_info()

    def _update_last_set_time(self):
        self._lastSetTime = time.time()

    @synchronized
    def set_up(self):
        s2s = self.get_settings()
        s2s.init_settings()
        self.set_settings(s2s)

    @synchronized
    @device_open_required
    def get_info(self):
        """
        Read information from the S2
        :return S2InfoWrapper:
        """
        s2i = S2_info()
        ret = s2_query_info(self._port, s2i)
        if ret != 0:
            raise PulserError("Failed to communicate with the device. Error: " + PulserDriver._get_error_name(ret))
        s2iw = self._info_wrapper(s2i)
        self._log('get_info()', s2iw)
        return s2iw

    def _log(self, method, wrapper):
        if self._verbose:
            self._logger.info('S2: {0}: {1}'.format(method, wrapper.to_dict()))

    @synchronized
    @device_open_required
    def get_settings(self):
        """
        Reads parameters from the S2
        :return S2SettingsWrapper:
        """
        s2s = S2_settings()
        ret = s2_query_settings(self._port, s2s)
        if ret != 0:
            raise PulserError("Failed to initialize settings. Error: " + PulserDriver._get_error_name(ret))
        s2sw = self._settings_wrapper(s2s, self.s2i)
        self._log('get_settings()', s2sw)
        return s2sw

    @synchronized
    @device_open_required
    def set_settings(self, s2s, retry_count=2):
        """
        Sets parameters on the S2.
        :param S2SettingsWrapper s2s: the settings to apply
        """
        start = time.time()
        self._update_last_set_time()
        ret = s2_set_settings(self._port, s2s.structure, False)
        self._log('set_settings()', s2s)

        ## BUGFIX: sometimes the set settings fails for no good reason -> mitigate the problem by retrying the command
        if ret == 84 and retry_count > 0:
            time.sleep(0.1)
            return self.set_settings(s2s, retry_count-1)

        if ret != 0:
            raise PulserError("Failed to set output voltage. Error: " + PulserDriver._get_error_name(ret))

    @synchronized
    @device_open_required
    def reset_overcurrent_flag(self):
        """
        Resets the OVERCURRENT status flag
        """
        # Cannot reset the undervoltage flag by design.
        ret = s2_reset_status_flag(self._port, S2_STATUS_OVERCURRENT)
        if ret != 0:
            raise PulserError("Failed to reset overcurrent flag. Error: " + PulserDriver._get_error_name(ret))

    def get_stabilization_time(self):
        """
        Gets an estimate of the instruments stabilization time. Currently it is calculated
        as the sum of the time required for the signal to stabilize and the time to get a
        current reading.
        :return:
        """
        return self.s2i.signal_stabilization_sec + self.s2i.measurement_stabilization_sec

    def wait_ready(self):
        """
        Waits until the instrument is ready to deliver correct readings. This is calculated
        from the last set_s2_settings call.
        :return:
        """
        stab_time = self.get_stabilization_time()
        while time.time() - self._lastSetTime <= stab_time:
            sleep(0.001)

    def is_open(self):
        return self._open

    @synchronized
    def close(self):
        if self._open:
            serial_close(self._port)
        self._open = False


if __name__ == '__main__':
    p = PulserDriver('/dev/ttyS1')
    p.open()
    print(p.get_info().to_dict())
    p.close()
